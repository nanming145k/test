C51 COMPILER V9.54   HAL                                                                   03/19/2018 09:53:23 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE HAL
OBJECT MODULE PLACED IN .\Output\hal.obj
COMPILER INVOKED BY: d:\Keil_v5\C51\BIN\C51.EXE Code\hal.c LARGE OPTIMIZE(4,SPEED) BROWSE INCDIR(..\..\Include) DEFINE(F
                    -OSC_160000) DEBUG OBJECTEXTEND PRINT(.\LST\hal.lst) TABS(2) OBJECT(.\Output\hal.obj)

line level    source

   1          
   2          #include <stdio.h>
   3          #include "N76E003.h"
   4          #include "Define.h"
   5          #include "Common.h"
   6          #include "Delay.h"
   7          #include "SFR_Macro.h"
   8          #include "Function_define.h"
   9          #include "hal.h"
  10          #include "rcvpkt.h"
  11          bit BIT_TMP;
  12          unsigned char bridge=0;
  13          /******************flash**************************/
  14          #if CALIB
  15          #define  PAGE_ERASE_AP 0x22
  16          #define  BYTE_PROGRAM_AP  0x21
  17          #define  CALIADDRESSH 0x47
  18          #define  CALIADDRESSL 0x80
  19          volatile unsigned char code Data_Flash[4] _at_ 0x4780;
  20          void WriteCC(u8 addr, u8 dat)
  21          {
  22   1        IAPCN = BYTE_PROGRAM_AP;  // Program 201h with 55h
  23   1        IAPAH = CALIADDRESSH;
  24   1        IAPAL = CALIADDRESSL+addr;
  25   1        IAPFD = dat;  
  26   1        set_IAPGO;
  27   1      }
  28          void Flash(u8 rpH,u8 rpL,u8 paH,u8 paL)
  29          {
  30   1        TA = 0xAA;  //CHPCON is TA protected
  31   1        TA = 0x55;
  32   1        CHPCON |= 0x01; //IAPEN = 1, enable IAP mode
  33   1        TA = 0xAA;  //IAPUEN is TA protected
  34   1        TA = 0x55;
  35   1        IAPUEN |= 0x01; //APUEN = 1, enable APROM update
  36   1        IAPCN = PAGE_ERASE_AP;  //Erase page 200h~27Fh
  37   1        IAPAH = CALIADDRESSH;
  38   1        IAPAL = CALIADDRESSL;
  39   1        IAPFD = 0xFF;
  40   1        TA = 0xAA;  //IAPTRG is TA protected
  41   1        TA = 0x55;
  42   1        IAPTRG |= 0x01;  //write to IAPGO to trigger IAP process
  43   1        
  44   1        WriteCC(0,rpH);
  45   1        WriteCC(1,rpL);
  46   1        WriteCC(2,paH);
  47   1        WriteCC(3,paL);
  48   1        
  49   1        TA = 0xAA;  //IAPUEN is TA protected
  50   1        TA = 0x55;
  51   1        IAPUEN &= ~0x01; //APUEN = 0, disable APROM update
  52   1        TA = 0xAA;  //CHPCON is TA protected
  53   1        TA = 0x55;
  54   1        CHPCON &= ~0x01; //IAPEN = 0, disable IAP mode  
C51 COMPILER V9.54   HAL                                                                   03/19/2018 09:53:23 PAGE 2   

  55   1      }
  56          #endif
  57          /*************************PWM***************************/
  58          void InitPWM(void)
  59          {
  60   1        P00_Quasi_Mode;    //PWM3
  61   1        P10_Quasi_Mode;    //PWM2
  62   1        P1SR|=0x01;
  63   1        P0SR|=0x01;
  64   1      
  65   1        set_SFRPAGE;
  66   1        PWMINTC=0x02;
  67   1        clr_SFRPAGE;
  68   1      
  69   1        PWM2_P10_OUTPUT_ENABLE;
  70   1        PWM3_P00_OUTPUT_ENABLE;
  71   1          PWM_IMDEPENDENT_MODE;
  72   1        PWM3_OUTPUT_INVERSE;
  73   1        PWMPH=0x03;
  74   1        PWMPL=0xfe;
  75   1        PWM2H=0;
  76   1        PWM2L=0;
  77   1        PWM3H=0;
  78   1        PWM3L=0;
  79   1      
  80   1        set_LOAD;
  81   1      }
  82          
  83          void SetPWM(uint32_t fre,uint16_t duty)
  84          {
  85   1        uint32_t clk = 16000000;
  86   1        uint16_t temp;
  87   1        uint16_t temp1;
  88   1        temp=clk/fre;
  89   1          temp1=(uint32_t)temp*duty/1000;
  90   1        PWMPH=temp>>8;
  91   1        PWMPL=temp;
  92   1        PWM2H =temp1>>8;
  93   1        PWM2L =temp1;
  94   1        temp1=temp-temp1;
  95   1        PWM3H =temp1>>8;
  96   1        PWM3L =temp1;
  97   1          set_LOAD;
  98   1      }
  99          
 100          void PWMEn(u8 type)
 101          {
 102   1        if(type==0)
 103   1        {
 104   2          clr_PWMRUN;
 105   2          PWM3_P00_OUTPUT_DISABLE;
 106   2          PWM2_P10_OUTPUT_DISABLE;
 107   2          set_LOAD;
 108   2          P00=0;
 109   2          P10=0;
 110   2          bridge=0;
 111   2        }
 112   1        else if(type==1)         //P00是电容端
 113   1        {
 114   2          PWM3_P00_OUTPUT_DISABLE;
 115   2          PWM2_P10_OUTPUT_ENABLE;
 116   2          set_LOAD;
C51 COMPILER V9.54   HAL                                                                   03/19/2018 09:53:23 PAGE 3   

 117   2          set_PWMRUN;
 118   2          P00=0;
 119   2          bridge=1;
 120   2        }
 121   1        else if(type==2)
 122   1        {   
 123   2            PWM3_P00_OUTPUT_ENABLE;
 124   2          PWM2_P10_OUTPUT_ENABLE;
 125   2          set_LOAD;
 126   2          set_PWMRUN;
 127   2          bridge=2;
 128   2        }
 129   1      }
 130          
 131          void PWMSet(void)
 132          {
 133   1      //  u32 clk = 16000000;
 134   1        u16 duty = power_ctrl_pram.duty_cycle;
 135   1        u32 fre = power_ctrl_pram.fre;
 136   1      
 137   1        if(duty>OPREATE_RANGE_DUTY_CYCLE_MAX)
 138   1        {
 139   2        //        fre-=(duty-OPREATE_RANGE_DUTY_CYCLE_MAX)*100;
 140   2                duty=OPREATE_RANGE_DUTY_CYCLE_MAX;
 141   2      #if APPLEQC
 142   2          if((Apple)&&(QC==2))
 143   2          {
 144   3            power_ctrl_pram.ctrl_type=PID_TYPE_DUTY;
 145   3            if(bridge==1)
 146   3            {
 147   4      //        printf("fb\n");
 148   4              PWMEn(2);
 149   4              duty=250;
 150   4            }       
 151   3          }
 152   2          else
 153   2      #endif      
 154   2             power_ctrl_pram.ctrl_type=PID_TYPE_FRE;
 155   2        }
 156   1      
 157   1        if(duty<OPREATE_RANGE_DUTY_CYCLE_MIN)
 158   1        {
 159   2                duty=OPREATE_RANGE_DUTY_CYCLE_MIN;
 160   2                    if((bridge==2)&&(QC==0))
 161   2                    {
 162   3                      fre=120000;
 163   3                      duty=OPREATE_RANGE_DUTY_CYCLE_MAX;
 164   3                      PWMEn(1); 
 165   3             //         printf("HB\n");
 166   3                      power_ctrl_pram.ctrl_type=PID_TYPE_FRE;
 167   3                    } 
 168   2      #if APPLEQC             
 169   2                if((Apple)&&(QC==2)&&(bridge==2))
 170   2                {
 171   3                //    fre = 126900;
 172   3                    PWMEn(1); 
 173   3          //        printf("hb\n");
 174   3                    duty=400;
 175   3                    power_ctrl_pram.ctrl_type=PID_TYPE_DUTY;
 176   3                }
 177   2      #endif
 178   2        }      
C51 COMPILER V9.54   HAL                                                                   03/19/2018 09:53:23 PAGE 4   

 179   1        if(fre>OPREATE_RANGE_FRE_MAX)
 180   1        {
 181   2          //        duty-=(fre-OPREATE_RANGE_FRE_MAX)/100;
 182   2                fre=OPREATE_RANGE_FRE_MAX;
 183   2      
 184   2                    {
 185   3                        power_ctrl_pram.ctrl_type = PID_TYPE_DUTY;    
 186   3           //             printf("duty!\n");
 187   3                    }
 188   2        }
 189   1        if(fre<Fremin)
 190   1        {
 191   2                fre=Fremin;  
 192   2                if(power_ctrl_pram.duty_cycle<OPREATE_RANGE_DUTY_CYCLE_MAX)
 193   2                  power_ctrl_pram.ctrl_type = PID_TYPE_DUTY; 
 194   2                    if((bridge==1)&&(QC==0))
 195   2                    {
 196   3                      fre=110000;
 197   3                      duty=300;
 198   3                      power_ctrl_pram.ctrl_type = PID_TYPE_DUTY; 
 199   3                      PWMEn(2); 
 200   3              //        printf("FB\r\n");
 201   3                    }
 202   2        }
 203   1        power_ctrl_pram.fre = fre;
 204   1        power_ctrl_pram.duty_cycle = duty;
 205   1        
 206   1        SetPWM(fre,duty);
 207   1        if(tx_phase==TX_PHASE_PT)
 208   1        {
 209   2          printf("fre=%lu \n",fre);
 210   2          printf("duty=%hu \n",duty);
 211   2        }
 212   1      }
 213          
 214          void Disable_coil_power(void)
 215          {
 216   1        PWMEn(0);
 217   1        Delay10us(2);
 218   1        DRIVEREN=0;
 219   1        Delay10us(1); 
 220   1      }
 221          
 222          void Enable_coil_power(void)
 223          {
 224   1        power_ctrl_pram.fre = INITIALFRE;
 225   1      //  if((tx_phase==TX_PHASE_PING)&&(QC==2))
 226   1      //    power_ctrl_pram.fre+=5000;
 227   1        power_ctrl_pram.duty_cycle = INITIALDUTY;
 228   1        power_ctrl_pram.ctrl_type = PID_TYPE_FRE;
 229   1        PWMSet(); 
 230   1        Delay10us(1); 
 231   1        DRIVEREN=1;
 232   1        Delay10us(4);    
 233   1        if(QC==2)
 234   1        PWMEn(1);
 235   1        else
 236   1        PWMEn(2);
 237   1      }
 238          
 239          
 240          /****************************ADC*******************************/
C51 COMPILER V9.54   HAL                                                                   03/19/2018 09:53:23 PAGE 5   

 241          u16 GetTemp(void)
 242          {
 243   1        u16 adc=0;
 244   1        u32 temp=0;
 245   1        u8 i;
 246   1        P07_Quasi_Mode;
 247   1        Enable_ADC_AIN2;
 248   1      
 249   1        for(i=0;i<10;i++)
 250   1        { 
 251   2          clr_ADCF;
 252   2          set_ADCS;
 253   2          while(ADCF == 0);
 254   2          adc=ADCRL;
 255   2          adc+=(u16)ADCRH<<4;
 256   2          temp+=adc;
 257   2        }
 258   1        clr_ADCF;
 259   1      //  return temp/10;
 260   1      #if VCC5V
                adc=(u16)(0.122*temp);
              #else
 263   1        adc=(u16)(0.08*temp);
 264   1      #endif
 265   1        return adc;
 266   1      }
 267          
 268          u16 GetVpeak(void)
 269          {
 270   1        u16 adc=0;
 271   1        u32 temp=0;
 272   1        u8 i;
 273   1        P11_Quasi_Mode;
 274   1        Enable_ADC_AIN7;
 275   1        for(i=0;i<10;i++)
 276   1        { 
 277   2          clr_ADCF;
 278   2          set_ADCS;
 279   2          while(ADCF == 0);
 280   2          adc=ADCRL;
 281   2          adc+=(u16)ADCRH<<4;
 282   2          temp+=adc;
 283   2        }
 284   1        clr_ADCF;
 285   1      //  return temp/10;
 286   1      #if VCC5V
                adc=(u16)(0.122*temp);
              #else
 289   1        adc=(u16)(0.08*temp);
 290   1      #endif
 291   1        return adc;
 292   1      }
 293          
 294          u16 GetVpa(void)
 295          {
 296   1        u16 adc=0;
 297   1        u32 temp=0;
 298   1        u8 i;
 299   1        P03_Quasi_Mode;
 300   1        Enable_ADC_AIN6;
 301   1        for(i=0;i<10;i++)
 302   1        { 
C51 COMPILER V9.54   HAL                                                                   03/19/2018 09:53:23 PAGE 6   

 303   2          clr_ADCF;
 304   2          set_ADCS;
 305   2          while(ADCF == 0);
 306   2        }
 307   1        for(i=0;i<10;i++)
 308   1        { 
 309   2          clr_ADCF;
 310   2          set_ADCS;
 311   2          while(ADCF == 0);
 312   2          adc=ADCRL;
 313   2          adc+=(u16)ADCRH<<4;   
 314   2          temp+=adc;
 315   2        }
 316   1        clr_ADCF;
 317   1      //  return temp/10;
 318   1      #if VCC5V
                adc=(u16)(0.382*temp);
              #else 
 321   1        adc=(u16)(0.3175*temp);
 322   1      #endif  
 323   1        return adc;
 324   1      }
 325          
 326           u16 GetIpa(void)
 327          {
 328   1        u16 adc=0;
 329   1        u32 temp=0;
 330   1        u8 i;
 331   1        P04_Quasi_Mode;
 332   1        Enable_ADC_AIN5;
 333   1      //    for(i=0;i<10;i++)
 334   1      //  { 
 335   1      //    clr_ADCF;
 336   1      //    set_ADCS;
 337   1      //    while(ADCF == 0);
 338   1      //  }
 339   1        for(i=0;i<10;i++)
 340   1        { 
 341   2          clr_ADCF;
 342   2          set_ADCS;
 343   2          while(ADCF == 0);
 344   2          adc=ADCRL;
 345   2          adc+=(u16)ADCRH<<4;
 346   2          temp+=adc;
 347   2        }
 348   1        clr_ADCF;
 349   1      //  return temp/10;
 350   1      #if VCC5V
                adc=(u16)(0.081*temp);
              #else
 353   1        adc=(u16)(0.081*temp);
 354   1      #endif
 355   1        return adc;
 356   1      }
 357          
 358          /***************************1ms int***********************************************/
 359          
 360          void InitTimer3(void)
 361          {  
 362   1        T3CON=0x04;    //16M/128=125K
 363   1        RH3=0xff;
 364   1        RL3=0x05;
C51 COMPILER V9.54   HAL                                                                   03/19/2018 09:53:23 PAGE 7   

 365   1        set_ET3;                                    //enable Timer3 interrupt
 366   1          set_EA;                                     //enable interrupts
 367   1          set_TR3;  
 368   1      }
 369          
 370          void TIMER_1ms_ENABLE(unsigned char on)
 371          {
 372   1        if(on)
 373   1        set_TR3;
 374   1        else
 375   1        clr_TR3;  
 376   1      }
 377          
 378          void Timer3_ISR (void) interrupt 16 
 379          {
 380   1      #if S50B
                static u16 i=0;
                static u16 j=0;  
                static u16 k=0;
                static u8 m=0;
              #endif  
 386   1        static u8 common=0;
 387   1        common++;
 388   1        if(common==4)
 389   1        {
 390   2          t_rp_cnt_1ms++;
 391   2          t_ce_cnt_1ms++; 
 392   2          t_pr_cnt_1ms++;
 393   2      #if FORT20
 394   2          if(hftofb)
 395   2            hftofb++;
 396   2      #endif      
 397   2          common=0;
 398   2        }
 399   1      #if S50B  
              #define CYCLE 11
              #define STEP  450
                if(ledon)
                {
                  k++;
                  i++;
                  if(i>CYCLE)
                    i=0;
                  if(i<j)
                    LED1=0;
                  else 
                    LED1=1;
                  
                  if(k%STEP==1)
                  {
                    if((j<CYCLE-2)&&(m==0))
                      j++;
                    else
                      m=1;
                    
                    if((j>0)&&(m==1))
                      j--;
                    else
                      m=0;
                  }
                  ledon++;
                  if(tx_phase==TX_PHASE_PT)
C51 COMPILER V9.54   HAL                                                                   03/19/2018 09:53:23 PAGE 8   

                  {
                    if(ledon>41000)
                    {
                      ledon=0;
                      i=0;
                      j=0;  
                      k=0;
                      m=0;        
                      LED1=1;
                    }
                  }
                  else if(ledon>16000)
                  {
                    ledon=0;
                    i=0;
                    j=0;  
                    k=0;
                    m=0;
                    LED1=1;
                  }     
                }   
              #endif  
 449   1        clr_TF3;
 450   1      }
 451          
 452          /******************************capture**********************************/
 453          void InitCapture(void)
 454          {
 455   1        P01_Input_Mode;
 456   1        P15_Input_Mode; 
 457   1        TIMER2_DIV_16;
 458   1        TIMER2_Auto_Reload_Capture_Mode;
 459   1      
 460   1        IC4_P01_CAP0_RisingEdge_Capture;
 461   1        IC7_P15_CAP1_RisingEdge_Capture;
 462   1      
 463   1          set_ECAP;                                   //Enable Capture interrupt
 464   1          set_TR2;
 465   1      }
 466          
 467          u16 TIM2_GetCounter(u8 i)
 468          { 
 469   1        u16 cap=0;
 470   1        if(i)
 471   1        {
 472   2          cap=C1L;
 473   2          cap+=C1H<<8;  
 474   2        } 
 475   1        else
 476   1        {
 477   2          cap=C0L;
 478   2          cap+=C0H<<8;
 479   2        } 
 480   1        return cap;
 481   1      }
 482          
 483          void Capture_ISR (void) interrupt 12
 484          {       
 485   1      
 486   1          if(0!=(CAPCON0&0x02))        //CAP1
 487   1          {
 488   2            rcv_packet_int_handler(1);
C51 COMPILER V9.54   HAL                                                                   03/19/2018 09:53:23 PAGE 9   

 489   2            CAPCON1^=0x04;             //触发翻转
 490   2            clr_CAPF1;
 491   2          }
 492   1          if(0!=(CAPCON0&0x01))    //CAP0
 493   1          {
 494   2      
 495   2            rcv_packet_int_handler(0);
 496   2            CAPCON1^=0x01;              //触发翻转
 497   2            clr_CAPF0;
 498   2          }
 499   1      }
 500          
 501          /******************************GPIO**********************************/
 502          void InitGPIO(void)
 503          {
 504   1        P05_PushPull_Mode;//DRIVER EN
 505   1        P14_OpenDrain_Mode;//D+
 506   1        P17_PushPull_Mode;//D-  
 507   1        P02_Quasi_Mode;//FAN
 508   1        P16_Quasi_Mode;//LED2
 509   1        P12_Quasi_Mode;//LED1
 510   1          
 511   1        DRIVEREN=0;
 512   1        Dp=0;
 513   1        Dn=0;
 514   1        FAN=0;
 515   1        LED2=1;
 516   1        LED1=1;
 517   1      }
 518          
 519          /***************************QC2.0**********************************/
 520          void QC20SHAKE(void)//2线
 521          {
 522   1      //    uint8_t i=0;
 523   1          Dp=0;//0.6V
 524   1          Dn=1;//0.6V
 525   1          Delay_ms(500); 
 526   1      #if NTCOPENSHORT
 527   1          if(ntc)
 528   1          LED1=1;
 529   1      #endif    
 530   1          Delay_ms(500); 
 531   1      #if NTCOPENSHORT
 532   1          if(ntc)
 533   1          LED1=0;
 534   1      #endif      
 535   1          Delay_ms(500); 
 536   1      #if NTCOPENSHORT
 537   1          if(ntc)
 538   1          LED1=1;
 539   1      #endif        
 540   1          
 541   1          
 542   1          
 543   1          Dn=0;//0V
 544   1          Delay_ms(500); 
 545   1      #if NTCOPENSHORT
 546   1          if(ntc)
 547   1          LED1=0;
 548   1      #endif  
 549   1          Delay_ms(500); 
 550   1      #if NTCOPENSHORT
C51 COMPILER V9.54   HAL                                                                   03/19/2018 09:53:23 PAGE 10  

 551   1          if(ntc)
 552   1          LED1=1;
 553   1      #endif  
 554   1          Delay_ms(500); 
 555   1      #if NTCOPENSHORT
 556   1          if(ntc)
 557   1          LED1=0;
 558   1      #endif      
 559   1      }
 560          
 561          void QC20OUT9V(void)//2线
 562          {
 563   1          Dp=1;//3.3V
 564   1          Dn=1;//0.6
 565   1      }
 566          void QC20OUT5V(void)//2线
 567          {     
 568   1          Dp=0;//0.6
 569   1          Dn=0;//0
 570   1      }
 571          void QC20OUT12V(void)//2线
 572          {     
 573   1          Dp=0;//0.6
 574   1          Dn=1;//0.6
 575   1      }
 576          
 577          /**********************************FSK*****************************/
 578          static void Delay_full_fsk(u8 full)
 579          {
 580   1        u16 cnt = 0;
 581   1        u16 cnt_target = 256;
 582   1        
 583   1        set_LOAD;
 584   1        if (full)
 585   1                  cnt_target=512;
 586   1        while(1)
 587   1        {
 588   2           PWMF=0;
 589   2           while(PWMF!=1);
 590   2           cnt += 1;
 591   2           if(cnt_target<=cnt)
 592   2           {
 593   3             break;
 594   3           } 
 595   2        };/*wait to full cycle send OK*/
 596   1      }
 597          
 598          #define DEEP_SAMSUNG    1
 599          void Fsksend_sa(void)
 600          {
 601   1        u8 full = 1;
 602   1        uint8_t i=0;
 603   1        clr_EA;
 604   1        Delay_ms(5);
 605   1        while(i<30)
 606   1        {
 607   2        full = 1;
 608   2        if (((i>=2)&&(i<=3))
 609   2          || ((i>=10)&&(i<=13))
 610   2          || ((i>=15)&&(i<=16))
 611   2          || ((i>=24)&&(i<=29)))
 612   2          full = 0;
C51 COMPILER V9.54   HAL                                                                   03/19/2018 09:53:23 PAGE 11  

 613   2        if (i%2)
 614   2          PWMPL+=DEEP_SAMSUNG;
 615   2        else
 616   2          PWMPL-=DEEP_SAMSUNG;
 617   2        Delay_full_fsk(full);
 618   2        i++;
 619   2        }
 620   1        set_EA;
 621   1        return;
 622   1      }
 623          #if ECH
 624          //#define DEEP_ECH    (2)
 625          void Fsksend_ech_power(int8_t deep_ech,int8_t power)
 626          {
 627   1        unsigned char sig=0;
 628   1        // 5'b + 3'b(power)
 629   1        
 630   1        clr_EA;
 631   1        if(power & 0x01){
 632   2          PWMPL-=deep_ech;
 633   2          Delay_full_fsk(0);
 634   2          PWMPL+=deep_ech;
 635   2          Delay_full_fsk(0);//1 b0
 636   2        }else{
 637   2          PWMPL-=deep_ech;
 638   2          Delay_full_fsk(1);//0 b0
 639   2          sig =1;
 640   2        }
 641   1        
 642   1         if(power & 0x02){
 643   2           if(sig){
 644   3            PWMPL+=deep_ech;
 645   3            Delay_full_fsk(0);
 646   3            PWMPL-=deep_ech;
 647   3            Delay_full_fsk(0);//1 b1
 648   3           }else{
 649   3            PWMPL-=deep_ech;
 650   3            Delay_full_fsk(0);
 651   3            PWMPL+=deep_ech;
 652   3            Delay_full_fsk(0);//1 b1
 653   3           }
 654   2        }else{
 655   2          if(sig){
 656   3            PWMPL+=deep_ech;
 657   3            Delay_full_fsk(1);//0 b1
 658   3            sig =0;
 659   3          }else{
 660   3            PWMPL-=deep_ech;
 661   3            Delay_full_fsk(1);//0 b1
 662   3            sig =1;
 663   3          }
 664   2        }
 665   1        
 666   1         if(power & 0x04){
 667   2           if(sig){
 668   3            PWMPL+=deep_ech;
 669   3            Delay_full_fsk(0);
 670   3            PWMPL-=deep_ech;
 671   3            Delay_full_fsk(0);//1 b2
 672   3           }else{
 673   3            PWMPL-=deep_ech;
 674   3            Delay_full_fsk(0);
C51 COMPILER V9.54   HAL                                                                   03/19/2018 09:53:23 PAGE 12  

 675   3            PWMPL+=deep_ech;
 676   3            Delay_full_fsk(0);//1 b2
 677   3           }
 678   2        }else{
 679   2          if(sig){
 680   3            PWMPL+=deep_ech;
 681   3            Delay_full_fsk(1);//0 b2
 682   3            sig =0;
 683   3          }else{
 684   3            PWMPL-=deep_ech;
 685   3            Delay_full_fsk(1);//0 b2
 686   3            sig =1;
 687   3          }
 688   2        }
 689   1        if(sig){
 690   2          PWMPL+=deep_ech;
 691   2          Delay_full_fsk(0);
 692   2          PWMPL-=deep_ech;
 693   2          Delay_full_fsk(0);//1 b3
 694   2          
 695   2          PWMPL+=deep_ech;
 696   2          Delay_full_fsk(1);//0 b4
 697   2          
 698   2          PWMPL-=deep_ech;
 699   2          Delay_full_fsk(0);
 700   2          PWMPL+=deep_ech;
 701   2          Delay_full_fsk(0);//1 b5
 702   2          
 703   2          PWMPL-=deep_ech;
 704   2          Delay_full_fsk(0);
 705   2          PWMPL+=deep_ech;
 706   2          Delay_full_fsk(0);//1 b6
 707   2          
 708   2          PWMPL-=deep_ech;
 709   2          Delay_full_fsk(0);
 710   2          PWMPL+=deep_ech;
 711   2          Delay_full_fsk(0);//1 b7
 712   2        
 713   2        }else{
 714   2          PWMPL-=deep_ech;
 715   2          Delay_full_fsk(0);
 716   2          PWMPL+=deep_ech;
 717   2          Delay_full_fsk(0);//1 b3
 718   2          
 719   2          PWMPL-=deep_ech;
 720   2          Delay_full_fsk(1);//0 b4
 721   2          
 722   2          PWMPL+=deep_ech;
 723   2          Delay_full_fsk(0);
 724   2          PWMPL-=deep_ech;
 725   2          Delay_full_fsk(0);//1 b5
 726   2          
 727   2          PWMPL+=deep_ech;
 728   2          Delay_full_fsk(0);
 729   2          PWMPL-=deep_ech;
 730   2          Delay_full_fsk(0);//1 b6
 731   2          
 732   2          PWMPL+=deep_ech;
 733   2          Delay_full_fsk(0);
 734   2          PWMPL-=deep_ech;
 735   2          Delay_full_fsk(0);//1 b7
 736   2        }
C51 COMPILER V9.54   HAL                                                                   03/19/2018 09:53:23 PAGE 13  

 737   1        
 738   1        set_EA;
 739   1        return;
 740   1      }
 741          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2829    ----
   CONSTANT SIZE    =     21    ----
   XDATA SIZE       =      2      49
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
