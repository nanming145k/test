C51 COMPILER V9.54   IDCFG                                                                 03/19/2018 09:53:24 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE IDCFG
OBJECT MODULE PLACED IN .\Output\idcfg.obj
COMPILER INVOKED BY: d:\Keil_v5\C51\BIN\C51.EXE Code\idcfg.c LARGE OPTIMIZE(4,SPEED) BROWSE INCDIR(..\..\Include) DEFINE
                    -(FOSC_160000) DEBUG OBJECTEXTEND PRINT(.\LST\idcfg.lst) TABS(2) OBJECT(.\Output\idcfg.obj)

line level    source

   1          #include "idcfg.h"
   2          
   3          #if ECH
   4          ECH_STATE_E ech_state = ECH_STATE_INIT;
   5          #endif
   6          
   7          
   8          void TX_Phase_ProcessCfg(TX_DETECT_INFO_S         *p_tx_info)
   9          {
  10   1          uint_8 optional_packet_cnt = 0;
  11   1          u8 order=0;
  12   1          u8  id_ext = 0;
  13   1          u8 t_ce_cnt_1ms_timeout = 23;
  14   1          RX_PACKET_STRUCTURE_S       *p_tx_receive_packet = NULL;
  15   1      //    u16 ipa;
  16   1      
  17   1          p_tx_info->t_delay = TIMING_POWER_CONTROL_HOLD_OFF_TIME_MIN;
  18   1          t_ce_cnt_1ms = 0;
  19   1          
  20   1          Reset_Receive_Packet();
  21   1      
  22   1          do
  23   1          {
  24   2            
  25   2              if(( t_ce_cnt_1ms >= t_ce_cnt_1ms_timeout)&&
  26   2                (tx.rcv_packet_info_v.packet_part<=1)&&
  27   2                (tx.rcv_packet_info_c.packet_part<=1))
  28   2              {
  29   3                      tx_phase = TX_PHASE_SELECT;
  30   3                      Delay_ms(10);
  31   3                      break; 
  32   3              }
  33   2              
  34   2              if(Receive_Packet(&p_tx_receive_packet))
  35   2                continue;
  36   2      
  37   2          t_ce_cnt_1ms = 0;
  38   2          switch ( p_tx_receive_packet->header)
  39   2          {
  40   3            /* receive ID Packet */
  41   3            case RX_PACKET_TYPE_INDENTIFICATION:      //鉴别包，判断是三星，苹果还是普通机
  42   3            {
  43   4              t_ce_cnt_1ms=0;
  44   4              if(order==0)
  45   4                order=1;
  46   4              t_ce_cnt_1ms_timeout = 30;
  47   4              id_ext = p_tx_receive_packet->msg[3]&0x80;
  48   4      //        id1=p_tx_receive_packet->msg[1];
  49   4      //        id2=p_tx_receive_packet->msg[2];
  50   4              vqi=p_tx_receive_packet->msg[0];
  51   4      //        printf("vqi=%bx\n",vqi);
  52   4              ech_state = ECH_STATE_INIT;
  53   4              if( (p_tx_receive_packet->msg[2] == 0x42)&&(p_tx_receive_packet->msg[3]== 0x64))
  54   4              {
C51 COMPILER V9.54   IDCFG                                                                 03/19/2018 09:53:24 PAGE 2   

  55   5                Xamsung = 1;
  56   5                if((p_tx_receive_packet->msg[4] == 0x40)&&(p_tx_receive_packet->msg[5]== 0x16))
  57   5                {
  58   6                  ech_state = ECH_STATE_ID_OK;
  59   6                }
  60   5              }
  61   4              else
  62   4                Xamsung = 0;
  63   4              #if ECH
  64   4                if ((p_tx_receive_packet->msg[1] == 0x00)
  65   4                  &&(p_tx_receive_packet->msg[2] == 0x59)
  66   4                  &&(p_tx_receive_packet->msg[3] == 0x64))
  67   4                {
  68   5                 if (QC == 2)
  69   5                    ech_state = ECH_STATE_SEND_HANDSHAKE; 
  70   5                  else
  71   5                    ech_state = ECH_STATE_ID_OK;
  72   5                  printf("ECH_ID\r\n");
  73   5                }
  74   4              #endif
  75   4      
  76   4              if( (p_tx_receive_packet->msg[1] == 0x00)&&(p_tx_receive_packet->msg[2] == 0x5A))
  77   4                Apple=1;
  78   4              else
  79   4                Apple=0;
  80   4      
  81   4              if((p_tx_receive_packet->msg[3]==0x30)&&(p_tx_receive_packet->msg[4]==0x31)&&(p_tx_receive_packet->msg
             -[5]==0x32)&&(p_tx_receive_packet->msg[6]==0x33))
  82   4              {
  83   5                BPP=1;
  84   5              }
  85   4              else
  86   4              {
  87   5                BPP=0;
  88   5                sfod=0;         
  89   5                if(Xamsung)
  90   5                {
  91   6                if(((sipa>105)&&(QC==0))||((sipa>70)&&(QC==2)))
  92   6                    {
  93   7                      sfod=1;           
  94   7                    }
  95   6                }
  96   5                else if(Apple)
  97   5                { 
  98   6                    if(((sipa>70)&&(QC==0))||((sipa>50)&&(QC==2)))
  99   6                    {
 100   7                      sfod=1;
 101   7                    }
 102   6                }
 103   5                else
 104   5                {
 105   6                   if(((sipa>150)&&(QC==0))||((sipa>90)&&(QC==2)))
 106   6                   {
 107   7                    sfod=1;
 108   7                   }
 109   6                }
 110   5                if(sfod)
 111   5                  printf("sipa large!\n");
 112   5            }
 113   4      //          printf(" %bu\n",p_tx_receive_packet->msg[0]);
 114   4      
 115   4            }
C51 COMPILER V9.54   IDCFG                                                                 03/19/2018 09:53:24 PAGE 3   

 116   3            break;
 117   3            
 118   3            /* receive EXT ID Packet*/ 
 119   3            case RX_PACKET_TYPE_EXTENDED_IDENTIFICATION:
 120   3            {
 121   4              t_ce_cnt_1ms=0;
 122   4              if(!id_ext)
 123   4              {
 124   5                tx_phase = TX_PHASE_SELECT;
 125   5              }
 126   4            }
 127   3            break;
 128   3      
 129   3            /* receive CFG Packet*/
 130   3            case RX_PACKET_TYPE_CONFIGURATION:
 131   3            {
 132   4              t_ce_cnt_1ms=0;
 133   4              if(order<1)   //判断是否鉴别
 134   4              {
 135   5                tx_phase = TX_PHASE_SELECT;  
 136   5                break;
 137   5              }
 138   4              order=2;
 139   4      
 140   4              p_tx_info->max_power_value = p_tx_receive_packet->msg[0]&0x3F;
 141   4      //        printf("mpv=%bd \n",p_tx_info->max_power_value);
 142   4              if( (p_tx_receive_packet->msg[2]&0x07) != optional_packet_cnt)
 143   4              {       
 144   5                tx_phase = TX_PHASE_SELECT;
 145   5                Delay_ms(10);
 146   5                break;
 147   5              }
 148   4              tx_phase = TX_PHASE_PT;
 149   4            }
 150   3            break;
 151   3      
 152   3            case RX_PACKET_TYPE_END_POWER_TRANSFER://EPT
 153   3            {
 154   4              tx_phase = COMPLETE;
 155   4      //#if FPDDET_EXITPT3TIMES_SUPPORT // exit pt 3 times
 156   4      //        exit_pt_info.reason_cur = EXIT_PT_REASON_EPT;
 157   4      //#endif
 158   4            }
 159   3            break;
 160   3                           
 161   3            //下都是count要+1的
 162   3            case RX_PACKET_TYPE_POWER_CONTROL_HOLD_OFF:
 163   3            {
 164   4              t_ce_cnt_1ms=0;
 165   4              if(order!=1)
 166   4              {
 167   5                tx_phase = TX_PHASE_SELECT;  
 168   5                break;
 169   5              }
 170   4              p_tx_info->t_delay = p_tx_receive_packet->msg[0];
 171   4              if( (p_tx_info->t_delay<TIMING_POWER_CONTROL_HOLD_OFF_TIME_MIN)
 172   4                        ||(p_tx_info->t_delay>TIMING_POWER_CONTROL_HOLD_OFF_TIME_MAX))
 173   4              {
 174   5                   tx_phase = TX_PHASE_SELECT;
 175   5                   Delay_ms(50);
 176   5                   break;
 177   5              }
C51 COMPILER V9.54   IDCFG                                                                 03/19/2018 09:53:24 PAGE 4   

 178   4            }                   
 179   3            case 0x18:
 180   3            case 0x19:
 181   3            case 0x28:
 182   3            case 0x29:
 183   3            case 0x38:
 184   3            case 0x48:
 185   3            case 0x58:
 186   3            case 0x68:
 187   3            case 0x78:
 188   3            case 0x84:
 189   3            case 0xa4:
 190   3            case 0xc4:
 191   3            case 0xe2:     
 192   3            {
 193   4              t_ce_cnt_1ms=0;
 194   4              if(order==0)
 195   4              {
 196   5      //          printf("Wrong order\n");
 197   5                tx_phase = TX_PHASE_SELECT;    
 198   5                break;
 199   5              } 
 200   4              optional_packet_cnt += 1;
 201   4              break;
 202   4            }
 203   3            default:
 204   3            break;
 205   3          }
 206   2          
 207   2          } while(tx_phase == TX_PHASE_IDCFG ); // cfg packet
 208   1      
 209   1          if (tx_phase != TX_PHASE_PT)
 210   1          {
 211   2      //    Delay_ms(5);
 212   2          Disable_coil_power();
 213   2          TIMER_1ms_ENABLE(DISABLE);
 214   2      #if NEW_TEMPDET_SLOW_CHARGING     
 215   2          temp_slow_state = 0;
 216   2      #endif      
 217   2          }
 218   1          return;  
 219   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1108    ----
   CONSTANT SIZE    =     22    ----
   XDATA SIZE       =      1      10
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
