C51 COMPILER V9.54   PT                                                                    03/19/2018 09:53:25 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE PT
OBJECT MODULE PLACED IN .\Output\pt.obj
COMPILER INVOKED BY: d:\Keil_v5\C51\BIN\C51.EXE Code\pt.c LARGE OPTIMIZE(4,SPEED) BROWSE INCDIR(..\..\Include) DEFINE(FO
                    -SC_160000) DEBUG OBJECTEXTEND PRINT(.\LST\pt.lst) TABS(2) OBJECT(.\Output\pt.obj)

line level    source

   1          #include "pt.h"
   2          
   3          #if DPLL
   4          u16 firstvpa=0;
   5          #endif
   6          u8 Save=0;
   7          u8 Savep=0;
   8          #if ECH
   9          extern ECH_STATE_E  ech_state;
  10          #endif
  11          u8 fod_effi[11] = {20,30,40,45,50,55,60,65,65,65,70};
  12          u8 pid_Kp[2][9] = {
  13                  {2, 2, 2, 6, 8, 10, 10, 10, 10},/*noraml*/
  14                  {2, 2, 3, 3, 6, 6,  10,  10, 10},/*samsung*/
  15                };/*from 100K~190K*/
  16          
  17          #if FORT20
  18          void HBtoFB(void)
  19          {
  20   1        if(bridge==1)
  21   1        {
  22   2      //    Delay_ms(200);
  23   2          power_ctrl_pram.fre +=15000;
  24   2      //    if(power_ctrl_pram.fre>OPREATE_RANGE_FRE_MAX)
  25   2      //    {
  26   2      //      power_ctrl_pram.fre=OPREATE_RANGE_FRE_MAX;
  27   2      //      power_ctrl_pram.duty_cycle=400;
  28   2      //      power_ctrl_pram.ctrl_type = PID_TYPE_DUTY;
  29   2      //    }
  30   2          PWMSet();
  31   2          PWMEn(2); 
  32   2          printf("FB\n");
  33   2          power_ctrl_pram.cecnt_after_toFB = 1;
  34   2        }
  35   1      } 
  36          #endif
  37          
  38          #if NEW_TEMPDET_SLOW_CHARGING 
  39          static uint8_t  pt_temp_control_slow(
  40                    uint8_t rpcount,
  41                    uint16_t power_received,
  42                    uint16_t papower,
  43                    uint8_t s8_bl
  44            )
  45          { 
  46   1        static uint8_t  rp_counter;
  47   1        
  48   1        static uint16_t rp_stable_cnt;
  49   1        static uint8_t  rp_notstable_cnt;
  50   1        static uint16_t stable_rp_value;
  51   1        
  52   1        static uint16_t pa_stable_cnt; 
  53   1        static uint8_t  pa_notstable_cnt;
  54   1        static uint16_t stable_pa_value;
C51 COMPILER V9.54   PT                                                                    03/19/2018 09:53:25 PAGE 2   

  55   1        
  56   1        uint8_t      overtempreason = 0;
  57   1        uint16_t    rp_check_thr = 400;
  58   1        uint16_t        stable_rp_thr = 1500;
  59   1        uint16_t        stable_pa_thr = 2000;
  60   1        
  61   1        if (rpcount == 0)
  62   1        {
  63   2          rp_stable_cnt = 0;
  64   2          rp_notstable_cnt = 0;
  65   2          stable_rp_value = 0;
  66   2          
  67   2          pa_stable_cnt = 0;
  68   2          pa_notstable_cnt = 0;
  69   2          stable_pa_value = 0;
  70   2      
  71   2          rp_counter = 0;
  72   2        }
  73   1      
  74   1         if(rp_counter < 0xff)
  75   1          rp_counter++;
  76   1         if ((rp_counter > 30)&&(ech_state == ECH_STATE_INIT)&&(s8_bl<100))
  77   1         {
  78   2            if (Samsung)
  79   2            {     
  80   3                rp_check_thr = 250;
  81   3                stable_rp_thr = 2500;
  82   3                stable_pa_thr = 4000;
  83   3            }
  84   2            
  85   2           if (Xamsung)
  86   2           {       
  87   3             if ((stable_rp_value < power_received + 250)
  88   3               &&(stable_rp_value > power_received - 250))
  89   3             {
  90   4               rp_stable_cnt ++;
  91   4               rp_notstable_cnt = 0;
  92   4               printf("rp_stable_cnt =%hu\n", rp_stable_cnt);
  93   4             }
  94   3             else
  95   3             {
  96   4               rp_notstable_cnt ++;
  97   4               if (rp_notstable_cnt > 5)
  98   4               {
  99   5                 stable_rp_value = power_received;
 100   5                 rp_stable_cnt = 0;          
 101   5               }
 102   4             }
 103   3             if (rp_stable_cnt > rp_check_thr)
 104   3             {
 105   4               printf("check stable_rp_value=%hu\n", stable_rp_value);
 106   4              if (stable_rp_value < stable_rp_thr)
 107   4                overtempreason = 1; 
 108   4              else
 109   4              {
 110   5                rp_stable_cnt = 0;
 111   5                stable_rp_value = 0;
 112   5                rp_notstable_cnt = 0;
 113   5               }  
 114   4             }       
 115   3      
 116   3             if ((stable_pa_value < papower + 250)
C51 COMPILER V9.54   PT                                                                    03/19/2018 09:53:25 PAGE 3   

 117   3               &&(stable_pa_value > papower - 250))
 118   3             {
 119   4               pa_stable_cnt ++;
 120   4               pa_notstable_cnt = 0;
 121   4               printf("pa_stable_cnt =%hu\n", pa_stable_cnt);
 122   4             }
 123   3             else
 124   3             {
 125   4               pa_notstable_cnt++;
 126   4               if (pa_notstable_cnt > 5)
 127   4               {
 128   5                 stable_pa_value = papower;
 129   5                 pa_stable_cnt = 0;
 130   5               }
 131   4             }
 132   3             if (pa_stable_cnt > rp_check_thr)
 133   3             {
 134   4               printf("stable_pa_value=%hu!!!!\n", stable_pa_value);
 135   4               if (stable_pa_value < stable_pa_thr)
 136   4                overtempreason = 2;
 137   4               else
 138   4               {
 139   5                pa_stable_cnt = 0;
 140   5                pa_notstable_cnt = 0;
 141   5                stable_pa_value = 0;
 142   5               }
 143   4             }       
 144   3           }
 145   2         }
 146   1      
 147   1         if (overtempreason) {
 148   2          printf("lp%bu\n", overtempreason);
 149   2         }
 150   1         return (overtempreason);
 151   1      }
 152          
 153          #endif
 154          #if APPLEQC
 155          void tan(void)
 156          {
 157   1                  if(power_ctrl_pram.fre == 127000)
 158   1                    power_ctrl_pram.fre = 126900;
 159   1                  else if(power_ctrl_pram.fre == 126900)
 160   1                    power_ctrl_pram.fre = 127000;
 161   1                  
 162   1                  PWMSet();
 163   1      }
 164          #endif
 165          void Ctrl_PIDAlgorithm(int_8 ctrl_error_val)
 166          {
 167   1          int_32 deltafre;
 168   1      
 169   1          //for( i=0; i<PID_LOOP_INTERATION_INDEX_MAX; i++)
 170   1          {
 171   2              Delay_ms(TIMING_EXECUTE_A_SINGLE_ITERATION);  // tinner, ms
 172   2              
 173   2              if(Samsung)
 174   2              {
 175   3                 Fremin=OPERATE_SANSUNG_FRE_MIN;
 176   3              }
 177   2              else
 178   2              {
C51 COMPILER V9.54   PT                                                                    03/19/2018 09:53:25 PAGE 4   

 179   3                Fremin=OPREATE_RANGE_FRE_MIN;
 180   3              }      
 181   2                  
 182   2              if ((power_ctrl_pram.cecnt_after_toFB)&&(power_ctrl_pram.cecnt_after_toFB < 10))
 183   2                Fremin += 20000;    
 184   2              
 185   2              if ((ctrl_error_val > 55)&&(Samsung))
 186   2                  ctrl_error_val = 55;
 187   2      if( PID_TYPE_FRE == power_ctrl_pram.ctrl_type)
 188   2      {
 189   3                  if(bridge==2)
 190   3                    deltafre=((int_32)ctrl_error_val*100); 
 191   3                  else
 192   3                    deltafre=((int_32)ctrl_error_val*300);  
 193   3                  if((ctrl_error_val==60)||(ctrl_error_val==-60))
 194   3                    deltafre*=1.5;
 195   3      
 196   3                  if(((ctrl_error_val==-1)||(ctrl_error_val==1)))
 197   3                    deltafre=0;
 198   3          
 199   3                    if(((ctrl_error_val==-2)||(ctrl_error_val==-3)||(ctrl_error_val==-4))&&(BPP))
 200   3                    {  
 201   4                      power_ctrl_pram.duty_cycle+=(int_16)(ctrl_error_val*2);  
 202   4                    } 
 203   3                    else
 204   3                      power_ctrl_pram.fre-=deltafre;
 205   3      }
 206   2      else   //duty
 207   2      {
 208   3        if(((ctrl_error_val==-1)||(ctrl_error_val==1)))
 209   3                ctrl_error_val=0;
 210   3         power_ctrl_pram.duty_cycle+=(int_16)(ctrl_error_val*1);     
 211   3      }
 212   2                PWMSet();
 213   2                return;          
 214   2          }
 215   1      }
 216          
 217          
 218          
 219          
 220          void TX_Phase_ProcessPT( TX_DETECT_INFO_S         *p_tx_info)
 221          {
 222   1          u8 bpprpnum=0;
 223   1         u16 lastrppower=0;
 224   1        
 225   1          int_8    ctrl_error_val;
 226   1          uint_16  power_received;
 227   1          u16 ipa;  
 228   1          u16 ipac; 
 229   1          u8 ipa0;    
 230   1          u8 ipa1;  
 231   1          u16 vpa;
 232   1          u16 papower=0;
 233   1          u8 firstce = 1;
 234   1          int_16 ploss = 0;
 235   1          u8 rpcount=0;
 236   1      #if !FORT20
                  u8 cecount=0;
              #endif
 239   1          u8 readyfsk=1;
 240   1          u8 NotCharging_Cnt = 0;
C51 COMPILER V9.54   PT                                                                    03/19/2018 09:53:25 PAGE 5   

 241   1          u8 Charging_Cnt = 0;
 242   1          u8 complete=0;
 243   1          u16 tempthr=0;
 244   1          u8 i = 0;
 245   1          u8 header,byte1,byte2,byte3;
 246   1          u32 cetimeout=TIMING_CONTROL_ERROR_PACKET_TIMEOUT;
 247   1          u16 vtemp=0;
 248   1      #if ECH
 249   1          unsigned char ECH_Rx_Required_Power = 5;
 250   1          u8 first_ce_zero = 1;
 251   1      #endif
 252   1      #if FULLNESS
 253   1             #define RP_FULLNESS_MORE_THAN_NUMBER  250 
 254   1             int  rp_full_number_of_conditions = 0;
 255   1             int  rp_unfull_number_of_conditions = 0;
 256   1             #define RP_FULLNESS_NUM 1000
 257   1      #endif
 258   1      #if FODDET
 259   1          u8 fodcount = 0;
 260   1      #endif
 261   1          int_8 last_ctrl_error_val=0;
 262   1      
 263   1          u8 cebutiao=0;
 264   1      #if DPLL
 265   1          u32 cntdown=0;
 266   1          u16 deltavpa=0;
 267   1      #endif
 268   1      #if NEW_TEMPDET_SLOW_CHARGING
 269   1          u8  s8_bl = 0;
 270   1      #endif  
 271   1      #if CALIB
 272   1          u8 caliben=0; 
 273   1      #endif
 274   1      #if APPLEQC
 275   1      u8 tantanle=1;
 276   1      u8 lock=0;
 277   1      #endif
 278   1          RX_PACKET_STRUCTURE_S       *p_tx_receive_packet = NULL;
 279   1          t_ce_cnt_1ms=0;
 280   1          t_rp_cnt_1ms=0;        
 281   1          t_pr_cnt_1ms=0; 
 282   1      #if FORT20         
 283   1          hftofb=0;
 284   1      #endif      
 285   1      
 286   1      #if DPLL
 287   1          firstvpa=GetVpa();
 288   1      //  if(firstvpa<4900)
 289   1      //    deltavpa=300;
 290   1      //  else
 291   1          deltavpa=500;
 292   1          printf("FirstVpa=%hu \n",firstvpa);
 293   1      #endif
 294   1      #if FPDDET_EXITPT3TIMES_SUPPORT
 295   1        exit_pt_info.reason_cur = EXIT_PT_REASON_UNKNOW;
 296   1      #endif  
 297   1          Reset_Receive_Packet();
 298   1          
 299   1      
 300   1          
 301   1          while(1)
 302   1          {
C51 COMPILER V9.54   PT                                                                    03/19/2018 09:53:25 PAGE 6   

 303   2            
 304   2      #if VPEAKDET  
 305   2            if(GetVpeak()>1870)
 306   2            {
 307   3              Disable_coil_power();
 308   3              tx_phase = TX_PHASE_SELECT;
 309   3              printf("VPEAK!!!\n");
 310   3       #if FPDDET_EXITPT3TIMES_SUPPORT // exit pt 3 times
 311   3              exit_pt_info.reason_cur = EXIT_PT_REASON_OVER_VPEAK;
 312   3       #endif       
 313   3              break;
 314   3            }
 315   2      #endif
 316   2      
 317   2            if((t_rp_cnt_1ms > TIMING_RECEIVED_POWER_PACKET_TIMEOUT)
 318   2                      &&(rpcount == 0))/*iphone rx timeout and Qi certi*/
 319   2            {
 320   3              tx_phase = TX_PHASE_SELECT;
 321   3              printf("RP timeout!!\n");
 322   3      #if FPDDET_EXITPT3TIMES_SUPPORT // exit pt 3 times
 323   3              exit_pt_info.reason_cur = EXIT_PT_REASON_RP_TO;
 324   3      #endif        
 325   3              break;
 326   3            }
 327   2            if(( t_pr_cnt_1ms >= 2000)||(( t_ce_cnt_1ms >= cetimeout)))
 328   2            {
 329   3                if( t_pr_cnt_1ms >= 2000)
 330   3                {
 331   4                  Savep++;
 332   4                  if(Savep>=3)
 333   4                  {
 334   5                    Savep=0;
 335   5                    tx_phase = TX_PHASE_SELECT;
 336   5                    printf("CE timeout \n");
 337   5      #if FPDDET_EXITPT3TIMES_SUPPORT // exit pt 3 times
 338   5                    exit_pt_info.reason_cur = EXIT_PT_REASON_CE_TO;
 339   5      #endif              
 340   5                    break;
 341   5                  } 
 342   4                  else
 343   4                  {
 344   5                    t_pr_cnt_1ms=0;
 345   5                    if(power_ctrl_pram.ctrl_type!=PID_TYPE_DUTY)
 346   5                      power_ctrl_pram.fre+=5000;
 347   5                    else
 348   5                      power_ctrl_pram.duty_cycle-=50; 
 349   5                    if(power_ctrl_pram.fre>OPREATE_RANGE_FRE_MAX)
 350   5                    {
 351   6                      power_ctrl_pram.fre=OPREATE_RANGE_FRE_MAX;
 352   6                      power_ctrl_pram.duty_cycle-=50;
 353   6                      power_ctrl_pram.ctrl_type = PID_TYPE_DUTY; 
 354   6                    }               
 355   5                    printf("Savep \n");
 356   5                  } 
 357   4                }
 358   3              else if( t_ce_cnt_1ms >= cetimeout)
 359   3              {
 360   4                  if(BPP)
 361   4                    Save=2;
 362   4                  else
 363   4                    Save++;
 364   4                  if(Save>=2)
C51 COMPILER V9.54   PT                                                                    03/19/2018 09:53:25 PAGE 7   

 365   4                  {
 366   5                      Save=0;
 367   5                      tx_phase = TX_PHASE_SELECT;
 368   5                      printf("CE timeout  \n");
 369   5      #if FPDDET_EXITPT3TIMES_SUPPORT // exit pt 3 times
 370   5                      exit_pt_info.reason_cur = EXIT_PT_REASON_CE_TO;
 371   5      #endif                
 372   5                      break;
 373   5                  }
 374   4                  else
 375   4                  {
 376   5                    t_ce_cnt_1ms = 0;
 377   5                    t_rp_cnt_1ms = 0;
 378   5                    if(power_ctrl_pram.ctrl_type!=PID_TYPE_DUTY)
 379   5                      power_ctrl_pram.fre+=5000;
 380   5                    else
 381   5                      power_ctrl_pram.duty_cycle-=50; 
 382   5                    if(power_ctrl_pram.fre>OPREATE_RANGE_FRE_MAX)
 383   5                    {
 384   6                      power_ctrl_pram.fre=OPREATE_RANGE_FRE_MAX;
 385   6                      power_ctrl_pram.duty_cycle-=50; 
 386   6                      power_ctrl_pram.ctrl_type = PID_TYPE_DUTY; 
 387   6                    }
 388   5                        
 389   5                        printf("Save \n");
 390   5                   }                     
 391   4              }   
 392   3                PWMSet(); 
 393   3              }
 394   2                   
 395   2      #if DPLL
 396   2               if(QC==0)
 397   2               {
 398   3                 cntdown=0;
 399   3                 do
 400   3                 {
 401   4                   cntdown++;
 402   4                   vpa=GetVpa()+deltavpa;
 403   4                   Delay10us(1);
 404   4                   if(cntdown>10)
 405   4                   {
 406   5                     printf("DPL+\n");
 407   5                     power_ctrl_pram.fre+=5000;
 408   5                     if(power_ctrl_pram.fre>OPREATE_RANGE_FRE_MAX)
 409   5                    {
 410   6                      power_ctrl_pram.fre=OPREATE_RANGE_FRE_MAX;
 411   6                      power_ctrl_pram.duty_cycle-=50; 
 412   6                      power_ctrl_pram.ctrl_type = PID_TYPE_DUTY; 
 413   6                    }
 414   5                     PWMSet();
 415   5                     cebutiao=4;
 416   5                     if(BPP)
 417   5                     {
 418   6                       LED1=1;
 419   6                       Delay_ms(100);
 420   6                       LED1=0;
 421   6                     }
 422   5                     break;
 423   5                   } 
 424   4                 } while(vpa<firstvpa);  
 425   3               }
 426   2      #endif          
C51 COMPILER V9.54   PT                                                                    03/19/2018 09:53:25 PAGE 8   

 427   2      #if FORT20         
 428   2              if(hftofb>200)
 429   2              {
 430   3                HBtoFB();
 431   3                cebutiao=3;
 432   3                hftofb=0;
 433   3              } 
 434   2      #endif           
 435   2              if(Receive_Packet(&p_tx_receive_packet))
 436   2                continue; 
 437   2              header = p_tx_receive_packet->header;
 438   2              byte1 = p_tx_receive_packet->msg[0];
 439   2              byte2 = p_tx_receive_packet->msg[1];
 440   2              byte3 = p_tx_receive_packet->msg[2];
 441   2              Save=0;
 442   2              Savep=0;
 443   2              if( header == RX_PACKET_TYPE_END_POWER_TRANSFER)    //收到停止传输能量信号
 444   2              {
 445   3      #if FPDDET_EXITPT3TIMES_SUPPORT // exit pt 3 times
 446   3                  exit_pt_info.reason_cur = EXIT_PT_REASON_EPT;
 447   3      #endif          
 448   3                  printf("EPT=%bd \n",byte1);
 449   3                  switch (byte1)      //判断停止电能传输的原因
 450   3                  {
 451   4                      case EPT_VALUE_UNKNOWN:             // unknown
 452   4                          if (ech_state > ECH_STATE_INIT)
 453   4                          {
 454   5                            tx_phase = TX_PHASE_SELECT;
 455   5                            Disable_coil_power();
 456   5                          }
 457   4                          else
 458   4                          {
 459   5                            tx_phase = COMPLETE;
 460   5                            Disable_coil_power();
 461   5                            Delay_ms(200);
 462   5                          }
 463   4                      break;
 464   4                      
 465   4                      case EPT_VALUE_OVER_TEMPERATURE:    // over temperature  
 466   4      #if NEW_TEMPDET_SLOW_CHARGING
 467   4                      if ((Samsung)&&(ech_state == ECH_STATE_INIT))
 468   4                      {
 469   5                        tx_phase = TX_PHASE_SELECT;
 470   5                        temp_slow_state = 1;
 471   5                        Disable_coil_power();
 472   5                        break;
 473   5                      }
 474   4      #endif            
 475   4                      case EPT_VALUE_RECONFIGURE:         // reconfigure
 476   4      
 477   4                      case EPT_VALUE_CHARGE_COMPLETE:     // charge complete
 478   4                        
 479   4      
 480   4                      case EPT_VALUE_INTERNAL_FAULT:      // internal fault
 481   4                      //no break;
 482   4                      case EPT_VALUE_OVER_VOLTAGE:        // over voltage
 483   4                      //no break;
 484   4                      case EPT_VALUE_OVER_CURRENT:        // over current
 485   4                      //no break;
 486   4                      case EPT_VALUE_BATTERY_FAILURE:     // battery failure
 487   4                      //no break;
 488   4                      
C51 COMPILER V9.54   PT                                                                    03/19/2018 09:53:25 PAGE 9   

 489   4                      default:
 490   4                        tx_phase = COMPLETE;
 491   4                        Disable_coil_power();
 492   4                        Delay_ms(200);
 493   4                      break;
 494   4                  }
 495   3                  break;
 496   3              }
 497   2              else if( header == RX_PACKET_TYPE_8BIT_RECEIVED_POWER)    //
 498   2              {        
 499   3      
 500   3                   printf("RP=%bu \n",byte1);
 501   3                        
 502   3                   
 503   3                   #if ECH
 504   3                     if(ech_state == ECH_STATE_HANDSHAKE_OK)
 505   3                     {
 506   4                        power_received = (uint_16)(((uint_32)ECH_Rx_Required_Power + 5) * byte1*1000/255);
 507   4                     }else
 508   3                   #endif
 509   3                      power_received = (uint_32)byte1*1000*p_tx_info->max_power_value>>8;
 510   3      //#if APPLEQC           
 511   3      //          if((Apple)&&(QC==2))
 512   3      //          {
 513   3      //            if(power_received>7000)
 514   3      //            {
 515   3      //              lock++;
 516   3      //              if(lock>2)
 517   3      //              tantanle=0;
 518   3      //            }
 519   3      //            else
 520   3      //              lock=0;
 521   3      //            if((tantanle)&&(power_received<5700))
 522   3      //          {
 523   3      //            tan();
 524   3      //          }
 525   3      //          if((power_received>5700)&&(power_received<6700)&&(tantanle))
 526   3      //          {
 527   3      //            tantanle++;
 528   3      //            if(tantanle==12)
 529   3      //            {
 530   3      //              tantanle=1;
 531   3      //              tan();
 532   3      //            }
 533   3      //          }
 534   3      //          else if(tantanle)
 535   3      //            tantanle=1;
 536   3      //          }
 537   3      //#endif                   
 538   3                  #if FULLNESS
 539   3                   if(Apple)
 540   3                   {
 541   4                    if(400 <= power_received && RP_FULLNESS_NUM + 250  >= power_received)
 542   4                    {
 543   5                      rp_full_number_of_conditions++;
 544   5                      printf("n=%d\r\n",rp_full_number_of_conditions);
 545   5                      if(rp_full_number_of_conditions >= RP_FULLNESS_MORE_THAN_NUMBER)
 546   5                      {
 547   6                        rp_unfull_number_of_conditions = 0;
 548   6                        rp_full_number_of_conditions = RP_FULLNESS_MORE_THAN_NUMBER + 1;
 549   6                        printf("F!!\r\n");
 550   6                        complete=1;
C51 COMPILER V9.54   PT                                                                    03/19/2018 09:53:25 PAGE 10  

 551   6                        LED1 = 1;
 552   6                      }
 553   5                      if(rp_full_number_of_conditions > 30)
 554   5                      {
 555   6                        rp_unfull_number_of_conditions = 0;
 556   6                      }
 557   5                    }
 558   4                    else
 559   4                    {
 560   5                      rp_unfull_number_of_conditions++;
 561   5                      if(rp_unfull_number_of_conditions > 5)
 562   5                      {
 563   6                        rp_unfull_number_of_conditions = 5;
 564   6                        rp_full_number_of_conditions = 0;
 565   6                        LED1 =0;
 566   6                        complete=0;
 567   6                      }
 568   5                    }
 569   4                   }
 570   3                  #endif
 571   3                   
 572   3                   ipa=GetIpa();
 573   3      #if CALIB       
 574   3                  if((Data_Flash[0]==0xff)&&(Data_Flash[1]==0xff))
 575   3                    caliben=0;
 576   3                  else
 577   3                  {
 578   4                    caliben=1;
 579   4        //            printf("cali %hd\n",(u16)Data_Flash[0]*100+Data_Flash[1]);
 580   4        //            printf("cali %hd\n",(u16)Data_Flash[2]*100+Data_Flash[3]);
 581   4                  }
 582   3                   if(caliben)
 583   3                   {
 584   4                     ipac=(u16)((u32)ipa*((u16)Data_Flash[0]*100+Data_Flash[1])/((u16)Data_Flash[2]*100+Data_Flash[3]))
             -;
 585   4                     printf("Ipac=%hu \n",ipac);
 586   4                   }
 587   3      #endif             
 588   3                   vpa=GetVpa();
 589   3                  if(vpa>MAX_PA_VOLTAGE)
 590   3                  {
 591   4                    tx_phase=OVP;
 592   4                    printf("OVP!\n");
 593   4      #if FPDDET_EXITPT3TIMES_SUPPORT // exit pt 3 times
 594   4                    exit_pt_info.reason_cur = EXIT_PT_REASON_POWER_LIMIT;
 595   4      #endif              
 596   4                    break;                     
 597   4                  }
 598   3                  if(ipa>2000)
 599   3                  {
 600   4                    tx_phase=TX_PHASE_SELECT;
 601   4                    printf("OCP!\n");
 602   4                    sfod=2;
 603   4      #if FPDDET_EXITPT3TIMES_SUPPORT // exit pt 3 times
 604   4                    exit_pt_info.reason_cur = EXIT_PT_REASON_POWER_LIMIT;
 605   4      #endif 
 606   4                    break; 
 607   4                  }
 608   3                   papower=(ipa/10)*(vpa/100);
 609   3                      
 610   3                   if(Samsung)
 611   3                   {
C51 COMPILER V9.54   PT                                                                    03/19/2018 09:53:25 PAGE 11  

 612   4                     FAN=1;
 613   4                     power_received=power_received*2; 
 614   4                     if(power_received>(papower*3/2))
 615   4                     power_received=power_received/2;
 616   4                   }
 617   3                   printf("Power_received=%hu ", power_received); 
 618   3                   printf("Power_pa=%hu \n", papower);   
 619   3                   printf("Vpa=%hu \n",vpa);
 620   3                   printf("Ipa=%hu \n",ipa);
 621   3                   
 622   3                   
 623   3      #if FODDET
 624   3      if(!BPP)
 625   3      { 
 626   4      
 627   4                  if((Xamsung)||(Apple))/*samsung. iphone*/
 628   4                {
 629   5                    ploss = (int16_t)papower -(int16_t)power_received;
 630   5                  #if S50B || ZENS
                            if(((ploss >= 5200)&& (ech_state >= ECH_STATE_ID_OK)) //T20
                              ||((ploss >= 4700)&&(rpcount > 20) && (ech_state == ECH_STATE_INIT)) //samsung apple
                              ||((ploss >= 3900)&&(rpcount <= 20)&&(Xamsung && ech_state == ECH_STATE_INIT))/*samsung fast/slow 
             -charging*/
                              ||((ploss >= 3200)&&(rpcount <= 20)&&(Apple))/*iphone slow charging*/
              #if APPLEQC
                              ||((papower>9200)&&(((Apple)&&(QC==0))||((!Samsung)&&(Xamsung))))  /*samsung/iphone slow charging*
             -/    
              #else
                              ||((papower>9200)&&((Apple)||(!Samsung)))  /*samsung/iphone slow charging*/ 
              #endif                         
                              ||(papower>15200))
                          #else
 642   5                    if(((ploss >= 5000)&&(ech_state >= ECH_STATE_ID_OK)) //T20
 643   5                      ||((ploss >= 4500)&&(rpcount > 20) && (ech_state == ECH_STATE_INIT)) //samsung apple
 644   5                      ||((ploss >= 3700)&&(rpcount <= 20)&&(Xamsung && ech_state == ECH_STATE_INIT))/*samsung fast/slow 
             -charging*/
 645   5      #if APPLEQC             
 646   5                      ||((ploss >= 3000)&&(rpcount <= 20)&&(Apple)&&(QC==0))/*iphone slow charging*/
 647   5                      ||((ploss >= 3700)&&(rpcount <= 20)&&(Apple)&&(QC==2))/*iphone fast charging*/
 648   5      #else
                              ||((ploss >= 3000)&&(rpcount <= 20)&&(Apple))
              #endif              
 651   5      #if APPLEQC
 652   5                      ||((papower>9000)&&(((Apple)&&(QC==0))||((!Samsung)&&(Xamsung))))  /*samsung/iphone slow charging*
             -/    
 653   5      #else
                              ||((papower>9000)&&((Apple)||(!Samsung)))  /*samsung/iphone slow charging*/ 
              #endif
 656   5                      ||(papower>15000))
 657   5                  #endif 
 658   5                    { 
 659   6                      if(rpcount>20)
 660   6                    fodcount++;
 661   6                      else
 662   6                      fodcount+=2;  
 663   6                    }
 664   5                  else
 665   5                  {
 666   6                    if(!sfod)
 667   6                    fodcount=0;
 668   6                  }
 669   5                }
C51 COMPILER V9.54   PT                                                                    03/19/2018 09:53:25 PAGE 12  

 670   4                else
 671   4                { 
 672   5                 i = power_received / 1000;
 673   5                 if(i > 10)
 674   5                   i = 10;
 675   5                 if((power_received < ((u32)papower * fod_effi[i]/100)) && (power_received>300))
 676   5                   fodcount+=2;
 677   5                 else if((power_received==0)&&(papower>1700))
 678   5                   fodcount+=2;
 679   5                 else 
 680   5                 {
 681   6                   if(!sfod)
 682   6                   fodcount=0;
 683   6                 }
 684   5               }
 685   4      if(sfod)
 686   4      fodcount+=4;
 687   4      if(vqi<0x11)
 688   4        fodcount=0;
 689   4                if ((fodcount > 7) || (papower>20000))
 690   4                {
 691   5                  tx_phase = TX_PHASE_SELECT;
 692   5                  sfod=2;
 693   5                  printf("FOD \n");
 694   5      #if FPDDET_EXITPT3TIMES_SUPPORT // exit pt 3 times
 695   5                  exit_pt_info.reason_cur = EXIT_PT_REASON_FOD;
 696   5      #endif            
 697   5                  break;
 698   5                }
 699   4      }
 700   3      else   //BPP FOD!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 701   3      {
 702   4                  if((power_received-lastrppower>35)&&(power_received-lastrppower<250)&&(bpprpnum<5)&&(power_received<
             -((u32)papower*65/100)))
 703   4                    fodcount++; 
 704   4                  else if(power_received<((u32)papower*20/100))
 705   4                    fodcount+=2;
 706   4                  else
 707   4                    fodcount=0;
 708   4                  
 709   4      //printf("powerdiff=%hu \n", power_received-lastrppower); 
 710   4      //printf("fodcount=%bu \n", fodcount);
 711   4                  lastrppower=power_received;
 712   4                  if(bpprpnum<10)
 713   4                  bpprpnum++;
 714   4                  if(fodcount>3)
 715   4                  {
 716   5                      tx_phase = TX_PHASE_SELECT;
 717   5                      sfod=2;
 718   5                      printf("FOD \n");
 719   5                      break;
 720   5                  }
 721   4                  
 722   4      }
 723   3      #endif
 724   3      #if TEMPDET
 725   3              vtemp=GetTemp();
 726   3              printf("Vtemp=%hu \n",vtemp);
 727   3              if(Apple||(Xamsung && (ech_state == ECH_STATE_INIT))) //xamsung apple use 60, T20 and others 70
 728   3                      tempthr=TEMPTH2;
 729   3              else
 730   3                      tempthr=TEMPTH1;
C51 COMPILER V9.54   PT                                                                    03/19/2018 09:53:25 PAGE 13  

 731   3             if(vtemp<tempthr)//
 732   3              {
 733   4                Delay_ms(50);
 734   4                if(GetTemp()<tempthr)
 735   4                {
 736   5                  tx_phase = OVERTEMP;
 737   5                  Disable_coil_power();
 738   5      #if FPDDET_EXITPT3TIMES_SUPPORT // exit pt 3 times
 739   5                  exit_pt_info.reason_cur = EXIT_PT_REASON_OVER_TEMP;
 740   5      #endif            
 741   5                  break;
 742   5                }
 743   4              }
 744   3      #endif        
 745   3      #if NEW_TEMPDET_SLOW_CHARGING 
 746   3             if(pt_temp_control_slow(rpcount, power_received, papower, s8_bl))
 747   3             {  
 748   4                temp_slow_state = 1;
 749   4                tx_phase = TX_PHASE_SELECT;
 750   4                if ((!Samsung)&&(Xamsung))
 751   4                {
 752   5                          uint16_t ipa_target = 0;
 753   5                          uint_8   cnt = 60; /*60*1s = 60s*/    
 754   5                        
 755   5                          Delay_ms(10);
 756   5                          Disable_coil_power();
 757   5      
 758   5                          while(cnt--)
 759   5                          {
 760   6                            Delay_ms(990);
 761   6                            Enable_coil_power();
 762   6                            Delay_ms(10);
 763   6                            ipa=GetIpa();
 764   6                            ipa-=IPA0;
 765   6                            if (ipa_target == 0 )
 766   6                              ipa_target = ipa;
 767   6                            Disable_coil_power();
 768   6                            printf("lp=%hu !\n", ipa);
 769   6                            if ((ipa > ipa_target + 7)
 770   6                               || (ipa_target > ipa + 7))
 771   6                            { 
 772   7                              temp_slow_state = 0;
 773   7                              break;
 774   7                            }
 775   6                          }             
 776   5                }
 777   4                break;
 778   4           }
 779   3      #endif        
 780   3                   if (rpcount <0xff)
 781   3                rpcount++;
 782   3          }
 783   2              // Control Error packet
 784   2              else if( header == RX_PACKET_TYPE_CONTROL_ERROR)
 785   2              {
 786   3                ctrl_error_val = (int_8)byte1;
 787   3      #if APPLEQC
 788   3                if((Apple)&&(QC==2))
 789   3                {
 790   4                power_ctrl_pram.fre = 129000;
 791   4                power_ctrl_pram.ctrl_type=PID_TYPE_DUTY;
 792   4                }
C51 COMPILER V9.54   PT                                                                    03/19/2018 09:53:25 PAGE 14  

 793   3      #endif
 794   3                if(firstce==1)
 795   3                {
 796   4      #if APPLEQC           
 797   4                  if((Apple)&&(QC==2))
 798   4                  {
 799   5      //              power_ctrl_pram.fre = 129000;
 800   5                    power_ctrl_pram.duty_cycle=350;
 801   5      //              power_ctrl_pram.ctrl_type=PID_TYPE_DUTY;
 802   5                  }
 803   4                  else
 804   4      #endif
 805   4                  {
 806   5                    power_ctrl_pram.fre = OPREATE_RANGE_FRE_MAX;
 807   5                    power_ctrl_pram.duty_cycle = OPREATE_RANGE_DUTY_CYCLE_MAX;
 808   5                  }
 809   4        //          PWMSet();
 810   4      #if !S50B
 811   4                  if(!Xamsung)
 812   4                  LED1=0;
 813   4      #else
                          ledon=1;          
              #endif
 816   4      
 817   4                }       
 818   3                else if((firstce>3)&&(ctrl_error_val!=55)&&(Xamsung))
 819   3                {
 820   4      #if !S50B           
 821   4                  LED1=0;
 822   4      #endif
 823   4                  firstce=0;
 824   4                }         
 825   3                if(firstce!=0)
 826   3                firstce++;
 827   3      //#if !S50B         
 828   3      //          if((papower<2000)&&(power_ctrl_pram.fre<Fremin+10000)&&(ctrl_error_val > 30))
 829   3      //          {
 830   3      //             if (NotCharging_Cnt < 0xff)
 831   3      //                NotCharging_Cnt++;
 832   3      //              Charging_Cnt = 0;
 833   3      //              if (NotCharging_Cnt == 10)
 834   3      //              LED1=1;
 835   3      //          }
 836   3      //          else if((((papower > 2200)&&(ctrl_error_val<10))||((papower > 3000)&&(power_received > 3000)))&
             -&(!complete))
 837   3      //          {
 838   3      //             NotCharging_Cnt = 0;
 839   3      //            if (Charging_Cnt < 0xff)
 840   3      //              Charging_Cnt++;
 841   3      //            if (Charging_Cnt==15)
 842   3      //              LED1=0;
 843   3      //          }
 844   3      //          else
 845   3      //          {
 846   3      //            NotCharging_Cnt = 0;
 847   3      //            Charging_Cnt = 0;
 848   3      //          }
 849   3      //#endif
 850   3      #if !FORT20
                        if(cecount!=0)
                          cecount++;
                        if((cecount==3)&&(bridge==1))
C51 COMPILER V9.54   PT                                                                    03/19/2018 09:53:25 PAGE 15  

                        {          
                          cecount=0;
                          power_ctrl_pram.fre +=15000;
              //            if(power_ctrl_pram.fre>OPREATE_RANGE_FRE_MAX)
              //            {
              //              power_ctrl_pram.fre=OPREATE_RANGE_FRE_MAX;
              //              power_ctrl_pram.duty_cycle-=50;
              //            }
                          PWMSet();
                          PWMEn(2); 
                          cebutiao=3;
                          printf("FB\n");
                          power_ctrl_pram.cecnt_after_toFB = 1;
                          continue;
                        }
              #endif  
 870   3                if((readyfsk!=0)&&(QC==2)&&(Xamsung==1))
 871   3                {       
 872   4                  if((readyfsk==1)/*&&(Xamsung==0)*/)
 873   4                  {
 874   5      #if NEW_TEMPDET_SLOW_CHARGING                 
 875   5                    if((temp_slow_state == 1))
 876   5      #endif                    
 877   5                    {
 878   6      #if NEW_TEMPDET_SLOW_CHARGING                   
 879   6                      temp_slow_state = 2;
 880   6      #endif                
 881   6                      readyfsk=0;
 882   6                      continue;
 883   6                    }
 884   5                  }     
 885   4                  readyfsk=0;
 886   4                  Fsksend_sa();
 887   4                  //printf("FSK for samsung!!\n");
 888   4                  continue;
 889   4                }
 890   3                
 891   3                 if((ctrl_error_val==-10)&&(Apple==1)&&(last_ctrl_error_val==0)) 
 892   3                 {
 893   4                   ipa=GetIpa();
 894   4                   vpa=GetVpa();
 895   4                   papower=(ipa/10)*(vpa/100);
 896   4                   if(papower>4000)
 897   4                   {
 898   5                      ctrl_error_val=0;
 899   5               //       printf("a-n\r\n");
 900   5                   }
 901   4                 }          
 902   3                
 903   3                last_ctrl_error_val = (int_8)byte1;
 904   3                Delay_ms(p_tx_info->t_delay);    
 905   3      #if ECH
 906   3        
 907   3            if(ech_state >= ECH_STATE_SEND_HANDSHAKE && first_ce_zero == 1 && ctrl_error_val == 0)
 908   3            {
 909   4                Fsksend_ech_power(2,4);  //1- <5W 2- 5W 3- 7.5W 4 10W 5- 12.5W 6- 15W
 910   4                first_ce_zero = 0;
 911   4                //ech_state = ECH_STATE_HANDSHAKE_OK;
 912   4                continue;
 913   4                
 914   4            }
 915   3            if ((ctrl_error_val == -127) 
C51 COMPILER V9.54   PT                                                                    03/19/2018 09:53:25 PAGE 16  

 916   3              &&(ech_state >= ECH_STATE_HANDSHAKE_OK))
 917   3            {
 918   4              power_ctrl_pram.fre += 35000;
 919   4              if(power_ctrl_pram.fre>OPREATE_RANGE_FRE_MAX)
 920   4                power_ctrl_pram.fre=OPREATE_RANGE_FRE_MAX;
 921   4              //PWMTimer1Set( power_ctrl_pram.fre,  power_ctrl_pram.duty_cycle);
 922   4              PWMSet();
 923   4              ctrl_error_val = 0;
 924   4              printf("ech%ld\r\n", power_ctrl_pram.fre);
 925   4            }
 926   3      #endif          
 927   3      //#if DPLL
 928   3                  if(cebutiao!=0) 
 929   3                  {
 930   4                    cebutiao--;
 931   4                    ctrl_error_val = 0;
 932   4                  }
 933   3      //#endif
 934   3                  printf("CE=%bd \n",ctrl_error_val);  
 935   3                  if(ASKch)
 936   3                    printf("ASK1 \n");
 937   3                  else
 938   3                    printf("ASK0 \n");
 939   3                  
 940   3                  if ((power_ctrl_pram.cecnt_after_toFB)&& (power_ctrl_pram.cecnt_after_toFB < 0xff))
 941   3                    power_ctrl_pram.cecnt_after_toFB++;                     
 942   3                  if((ctrl_error_val!=0)&&((cebutiao==0)||(ctrl_error_val<0)))
 943   3                  {
 944   4                       Ctrl_PIDAlgorithm( ctrl_error_val); //ta(j-1), c(j)
 945   4                  }
 946   3                  Delay_ms(TIMING_POWER_CONTROL_SETTLING_TIME);     
 947   3                  
 948   3              }
 949   2              else if(header == RX_PACKET_TYPE_CHARGE_STATUS)
 950   2              {        
 951   3                    if(byte1==100)
 952   3                    {
 953   4                        complete=1;
 954   4      #if !S50B               
 955   4                        LED1=1;
 956   4      #endif                
 957   4                        printf("Charging=%bd!!\r\n",byte1);
 958   4      #if NEW_TEMPDET_SLOW_CHARGING
 959   4                        s8_bl = 100;
 960   4      #endif                
 961   4                    }
 962   3                    else
 963   3                    {   
 964   4      #if !S50B               
 965   4                      LED1=0;
 966   4      #endif                
 967   4                      complete=0;
 968   4                    }
 969   3              } 
 970   2      #if SAMSUNG        
 971   2              else if((header == 0x18)&&(QC==2))
 972   2              {
 973   3                    Samsung=1;
 974   3                    printf("It's samsung\n");
 975   3              }
 976   2      
 977   2              else if (header == 0x28)
C51 COMPILER V9.54   PT                                                                    03/19/2018 09:53:25 PAGE 17  

 978   2              {
 979   3                  printf("0x28,%bx,%bx \r\n",byte1,byte2);
 980   3                  if((byte1==0x06)&&(byte2==0x2c))
 981   3                  {
 982   4      #if FORT20
 983   4                    hftofb=1;
 984   4      #else             
                            cecount=1;
              #endif  
 987   4                    Samsung=1;
 988   4            //        printf("Ready to full buridge 28 06 2C\n");
 989   4                    continue;
 990   4                  }
 991   3                  else if((byte1==0x00)&&(byte2==0x01))
 992   3                  {
 993   4      #if FORT20
 994   4                    hftofb=1;
 995   4      #else             
                            cecount=1;
              #endif  
 998   4                    Samsung=1;
 999   4            //        printf("Ready to full buridge 28 00 01\n");
1000   4                    continue;
1001   4                  }
1002   3                  else if((byte1==0x0c)&&(byte2==0x00))
1003   3                  {
1004   4      #if NEW_TEMPDET_SLOW_CHARGING
1005   4                    if (temp_slow_state == 0)
1006   4      #endif              
1007   4                    readyfsk=2;
1008   4                    continue;
1009   4                  }
1010   3                  else if((byte1==0x01)&&(byte2==0x00))
1011   3                  {
1012   4      #if NEW_TEMPDET_SLOW_CHARGING
1013   4                    if (temp_slow_state == 0)
1014   4      #endif              
1015   4                    readyfsk=2;
1016   4                    continue;
1017   4                  }         
1018   3      #if NEW_TEMPDET_SLOW_CHARGING
1019   3                  else if(byte1==0x0f)/*sangsung S8 power level*/
1020   3                  {
1021   4                    s8_bl = byte2;
1022   4                  }
1023   3      #endif    
1024   3                  
1025   3          }
1026   2      #endif
1027   2      #if ECH
1028   2             else if (header == RX_PACKET_TYPE_ECH_HANDSHAKE)
1029   2             {
1030   3                printf("0x19 %x\r\n", p_tx_receive_packet->msg[0]);
1031   3                if (ech_state == ECH_STATE_SEND_HANDSHAKE && first_ce_zero == 0 && p_tx_receive_packet->msg[0]> 
             -5*2){
1032   4                  
1033   4                  ech_state = ECH_STATE_HANDSHAKE_OK;
1034   4                  ECH_Rx_Required_Power = ((unsigned char)p_tx_receive_packet->msg[0])/2;
1035   4                    
1036   4                  Delay_ms(5);
1037   4                  power_ctrl_pram.fre +=15000;
1038   4                  if(power_ctrl_pram.fre>OPREATE_RANGE_FRE_MAX)
C51 COMPILER V9.54   PT                                                                    03/19/2018 09:53:25 PAGE 18  

1039   4                      power_ctrl_pram.fre=OPREATE_RANGE_FRE_MAX;
1040   4                  PWMSet();
1041   4                  PWMEn(2); 
1042   4                  printf("FB\r\n");
1043   4                  power_ctrl_pram.cecnt_after_toFB = 1;
1044   4                }else if(ech_state == ECH_STATE_SEND_HANDSHAKE && first_ce_zero == 0 && p_tx_receive_packet->msg
             -[0] <= 5*2)
1045   3                {
1046   4                  ech_state = ECH_STATE_HANDSHAKE_OK;
1047   4                  ECH_Rx_Required_Power = ((unsigned char)p_tx_receive_packet->msg[0])/2;;
1048   4                }
1049   3             }
1050   2      #endif
1051   2            else if((header == RX_PACKET_TYPE_SIGNAL_STRENGTH)
1052   2            ||(header == RX_PACKET_TYPE_CONFIGURATION)
1053   2            ||(header == RX_PACKET_TYPE_INDENTIFICATION)
1054   2            ||(header == RX_PACKET_TYPE_EXTENDED_IDENTIFICATION))
1055   2              {  
1056   3                Disable_coil_power();
1057   3                Delay_ms(10);
1058   3                tx_phase = TX_PHASE_SELECT;
1059   3                printf("Wrong pkt(0x%bx)\n",header);
1060   3      #if FPDDET_EXITPT3TIMES_SUPPORT // exit pt 3 times
1061   3                exit_pt_info.reason_cur = EXIT_PT_REASON_WRONG_PACKET;
1062   3      #endif    
1063   3                break;
1064   3              } 
1065   2            else if(header == RX_PACKET_TYPE_POWER_CONTROL_HOLD_OFF)
1066   2            {
1067   3      //        if(BPP)
1068   3              {
1069   4                if(firstce==1)
1070   4                {
1071   5                Delay_ms(5);  
1072   5                Disable_coil_power();
1073   5                Delay_ms(10);
1074   5                tx_phase = TX_PHASE_SELECT;
1075   5      //          printf("Wrong pkt(0x%bx)\n",header);
1076   5      #if FPDDET_EXITPT3TIMES_SUPPORT // exit pt 3 times
1077   5                exit_pt_info.reason_cur = EXIT_PT_REASON_WRONG_PACKET;
1078   5      #endif    
1079   5                break;  
1080   5                }           
1081   4              }
1082   3            }
1083   2      #if CALIB     
1084   2            else if(header==0x3f)
1085   2            {
1086   3              if(byte1==0xec)
1087   3              {
1088   4                ipa=GetIpa();
1089   4      //          printf("Ipa=%hu \n",ipa);
1090   4                ipa0=(u8)(ipa/100);
1091   4                ipa1=(u8)(ipa-(u16)ipa0*100);
1092   4                Flash(byte2,byte3,ipa0,ipa1);
1093   4      //          printf("%hd\n",(u16)Data_Flash[2]*100+Data_Flash[3]);
1094   4                printf("ccok %hd\n",(u16)Data_Flash[0]*100+Data_Flash[1]);
1095   4                
1096   4              }
1097   3            }
1098   2      #endif            
1099   2          }
C51 COMPILER V9.54   PT                                                                    03/19/2018 09:53:25 PAGE 19  

1100   1      
1101   1          if(tx_phase != TX_PHASE_PT)
1102   1          {
1103   2            TIMER_1ms_ENABLE(DISABLE);
1104   2            Disable_coil_power();
1105   2            FAN=0;
1106   2            
1107   2      #if FPDDET_EXITPT3TIMES_SUPPORT 
1108   2            if((exit_pt_info.reason_last == exit_pt_info.reason_cur)&&(exit_pt_info.reason_cur!=EXIT_PT_REASON_UNKN
             -OW))
1109   2            {
1110   3              exit_pt_info.pt_cnt += 1;
1111   3              if((ech_state > ECH_STATE_INIT)&&(exit_pt_info.reason_cur==EXIT_PT_REASON_EPT)&&(p_tx_receive_packet->
             -msg[0]==EPT_VALUE_UNKNOWN))
1112   3              {
1113   4                exit_pt_info.pt_cnt-=1;
1114   4              }
1115   3              if(3<=exit_pt_info.pt_cnt)
1116   3              {
1117   4                printf("exit pt 3 time \n");
1118   4                exit_pt_info.exit_pt_flag = 1;
1119   4              }
1120   3            }
1121   2            else
1122   2            {
1123   3              exit_pt_info.pt_cnt = 1;
1124   3            }
1125   2            printf("[pt];reason_cur=%bu, reason_last=%bu, exit_pt_cnt=%bu\n",\
1126   2                 exit_pt_info.reason_cur,exit_pt_info.reason_last,exit_pt_info.pt_cnt);
1127   2            exit_pt_info.reason_last = exit_pt_info.reason_cur;
1128   2      
1129   2      #endif      
1130   2            
1131   2          }
1132   1      #if NEW_TEMPDET_SLOW_CHARGING
1133   1          if (temp_slow_state == 2)
1134   1            temp_slow_state = 0;
1135   1      #endif
1136   1          return;
1137   1      }
1138          
1139          
1140          
1141          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6152    ----
   CONSTANT SIZE    =    522    ----
   XDATA SIZE       =     44      83
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
